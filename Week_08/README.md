# 学习笔记
本周学习了位运算，布隆过滤器和LRU缓存

## 位运算：

数字在计算机中储存的格式就是二进制，位运算直接操作二进制位，效率高。基本的位运算操作包括：左移（<<）、右移（>>）、按位或（|）、按位与（&）、按位取反（~）、按位异或（^）。逻辑移位是指逻辑左移和逻辑右移，移出的空位都用0来补。算术移位需要分有符号型值和无符号型值。对于无符号型值，算术移位等同于逻辑移位。而对于有符号型值，算术左移等同于逻辑左移，算术右移补的是符号位，正数补0，负数补1。
各种有用的操作如下：
* 将x最右边的n位清零：x&(~0 << n)
* 获取x的第n位值（0|1）：(x>>n)&1
* 获取x的第n位的幂值：x&(1<<n)
* 仅将第n位置为1：x|(1 << n)
* 仅将第n位置为0：x&(~(1<< n))
* 将x最高位至第n位（含）清零 x&((1<< n) -1)

## 布隆过滤器：

有时候只需要判断元素是否存在，因此使用一种占用空间小的数据结构。布隆过滤器是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。布隆过滤器的优点是空间效率和查询时间都远超过一般的算法，缺点是有一定的误识别率和删除困难。如果一个元素对应的二进制位都是1，则该元素可能在索引中（不能确定）。如果一个元素对应的二进制位包含0，则该元素一定不在索引中。布隆过滤器的作用是在最外层的快速查询的缓存，排除一定不在索引中的元素。如果一个元素可能在索引中，则需要进一步查询判断是否存在（例如在数据库表中查询）。这样做的优点是，空间效率和查询时间都远远超过一般的算法，布隆过滤器存储空间和插入 / 查询时间都是常数O(k)。另外, 散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。但是误算率是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。(误判补救方法是：再建立一个小的白名单，存储那些可能被误判的信息。)

## LRU缓存：
两个要素：大小、替换策略。使用哈希表和双向链表实现。查询、修改、更新的时间复杂度都是O(1)。

## 排序算法：

比较类排序和非比较类排序两种。前者通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(n log n)，因此也称为非线性时间比较类排序。比较类排序的例子：交换排序（冒泡排序、快速排序）、插入排序（简单插入排序、希尔排序）、选择排序（简单选择排序、堆排序）、归并排序（二路归并排序、多路归并排序）。后者不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。

初级排序算法有：选择排序（Selection Sort），插入排序（Insertion Sort），冒泡排序（Bubble Sort）。高级排序算法有：快速排序（Quick Sort），归并排序（Merge Sort）和堆排序（Heap Sort） 

## 基本的排序算法如下：冒泡排序，插入排序，选择排序.

```
void BubbleSort(vector<int>& data) {
    if (data.empty()) return;
    int n = data.size();
    bool isChanged = false;
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (data[j] > data[j + 1]) {
                int tmp = data[j];
                data[j] = data[j + 1];
                data[j + 1] = tmp;
                isChanged = true;
            }
        }
        if (!isChanged) return;
        isChanged = !isChanged;
    }
}
```

```
void InsertionSort(vector<int>& data) {
    if (data.empty()) return;
    int n = data.size();
    for (int i = 1; i < n; ++i) {
        for (int j = i; j > 0; --j) {
            if (data[j - 1] > data[j]) {
                int tmp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = tmp;
            }
        }
    }
}
```

```
void selectionSort(int Array[], int len) {
    int i,j,k,min;
    for (i = 0; i < len-1; i ++) {
        min = Array[i];
        k = i;//k为最小值的下标
        for (j=i+1; j < len; j ++) {
            if (min > Array[j]) {
                min = Array[j];
                k = j;
            }
        }
        Array[k] = Array[i];
        Array[i] = min;
    }
}  
```

 

